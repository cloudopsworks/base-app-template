##
# (c) 2022-2024 - Cloud Ops Works LLC - https://cloudops.works/
#            On GitHub: https://github.com/cloudopsworks
#            Distributed Under Apache v2.0 License
#
name: Deploy to AWS API Gateway
on:
  workflow_call:
    inputs:
      release_version:
        required: true
        type: string
      release_name:
        required: false
        type: string
      environment:
        required: true
        type: string
      package_name:
        required: false
        type: string
        default: ''
      package_type:
        required: false
        type: string
        default: ''
      deployment_name:
        required: true
        type: string
      target_cloud:
        required: true
        type: string
      BOT_USER:
        required: true
        type: string
      BOT_EMAIL:
        required: true
        type: string
      AWS_REGION:
        required: false
        type: string
    secrets:
      token:
        required: true
      AWS_ACCESS_KEY_ID:
        required: false
      AWS_SECRET_ACCESS_KEY:
        required: false
      AZURE_SERVICE_ID:
        required: false
      AZURE_SERVICE_SECRET:
        required: false

env:
  tofu_version: 1.7.1
  tg_version: 0.59.5
  base_app_version: 3
jobs:
  deployment-plan:
    runs-on: ubuntu-latest
    environment: ${{ inputs.deployment_name }}
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          path: source
          fetch-depth: 1
          token: ${{ secrets.token }}

      - name: Checkout Base App Template
        uses: actions/checkout@v4
        with:
          repository: cloudopsworks/base-app-template
          path: cd-${{ inputs.environment }}
          fetch-depth: 1
          ref: v${{ env.base_app_version }}
          token: ${{ secrets.token }}

      # Get the owner repo
      - name: Get owner
        id: getowner
        run: |
          repo_owner=`echo "$GITHUB_REPOSITORY" | cut -f 1 -d "/"`
          repo_name=`echo "$GITHUB_REPOSITORY" | cut -f 2 -d "/"`
          echo "owner=$repo_owner" >> $GITHUB_OUTPUT
          echo "repo_name=$repo_name" >> $GITHUB_OUTPUT

      - name: Set Final Release Name
        id: release_name
        run: |
          REL=
          if [ -z "${{ inputs.release_name }}" ]; then
            REL="${{ steps.getowner.outputs.repo_name }}"
          else
            REL="${{ inputs.release_name }}"
          fi
          echo "value=$REL" >> $GITHUB_OUTPUT

      - name: Setup OpenTofu
        id: setup_opentofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.tofu_version }}
          tofu_wrapper: false

      - name: Setup Terragrunt v${{ env.tg_version }}
        run: |
          sudo wget -q -O /bin/terragrunt "https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.tg_version }}/terragrunt_linux_amd64"
          sudo chmod +x /bin/terragrunt
          terragrunt -v

      - name: Copy configurations
        run: |
          cp -pf source/.github/vars/apigw/apis-${{ inputs.environment }}.yaml cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw/inputs.yaml
          cp -pf source/.github/vars/apigw/apis-global.yaml cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw/inputs-apis.yaml
          cp -pf source/.github/vars/inputs-global.yaml cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw/inputs-global.yaml

      - name: Copy API Files Bundle
        run: |
          mkdir -p cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw/apifiles/

      - name: Process all API Files
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.token }}
          script: |
            // Load the following YAML files as objects: inputs.yaml and intputs-apis.yaml
            const fs = require('fs');
            const yaml = require('js-yaml');
            const inputs = yaml.load(fs.readFileSync('cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw/inputs.yaml', 'utf8'));
            const apis = yaml.load(fs.readFileSync('cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw/inputs-apis.yaml', 'utf8'));
            
            // Process all API files in apifiles folder
            const path = 'source/apifiles/';
            const path_out = 'cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw/apifiles/';
            const files = fs.readdirSync(path);
            for (const file of files) {
              // determine if it is YAML file or JSON file use a variable for later decision
              const is_yaml = file.endsWith('.yaml');
              const is_json = file.endsWith('.json');
              if (!is_yaml && !is_json) {
                console.log(`Skipping ${file} as it is not a YAML or JSON file`);
                continue;
              }
              var fext = is_yaml ? '.yaml' : '.json';
              const api = apis.apis.find(api => api.apisource === file.replace(fext, ''));
              if (!api) {
                console.log(`API definition not found for ${file}`);
                continue;
              }
              console.log(`Processing ${file} for ${api.name}`);
              const content = fs.readFileSync(`${path}${file}`, 'utf8');
              var apiContent = {};
              if (is_json) {
                apiContent = JSON.parse(content);
              } else {
                apiContent = yaml.load(content);
              }
              
              // From inputs.yaml, get the mappings for aws: section to process the authorizers
              const authorizers = inputs.aws.authorizers;
              // Iterate all authorizers lookup if the authorizer is already defined in the API content securitySchemes as entry
              // if already exists modify the entry, if not found insert the authorizer in the API content securitySchemes
              for (const authorizer of authorizers) {
                const obj = {
                  name: 'Authorization',
                  type: (authorizer.authtype === 'lambda') ? 'apiKey' : authorizer.authtype,
                  in: 'header'
                };
                obj['x-amazon-apigateway-authtype'] = (authorizer.authtype === 'lambda') ? 'custom' : authorizer.authtype;
                obj['x-amazon-apigateway-authorizer'] = {
                  authorizerUri: authorizer.lambda.uri,
                  authorizerCredentials: authorizer.lambda.exec_role,
                  identitySource: 'method.request.header.Authorization',
                  authorizerResultTtlInSeconds: 0,
                  type: 'request'
                };

                if (apiContent.components.securitySchemes && apiContent.components.securitySchemes[authorizer.name]) {
                  console.log(`Authorizer ${authorizer.name} found in ${file}`);

                  // If found, modify the entry
                  apiContent.components.securitySchemes[authorizer.name] = obj;
                  continue;
                }
                console.log(`Authorizer ${authorizer.name} not found in ${file}`);
                // If not found, insert the authorizer in the API content securitySchemes
                if (!apiContent.components.securitySchemes) {
                  apiContent.components.securitySchemes = {};
                }
                apiContent.components.securitySchemes[authorizer.name] = obj;
              }
              // Write the modified API content as JSON back into destination apifiles
              fs.writeFileSync(`${path_out}${api.name}.json`, JSON.stringify(apiContent, null, 2));
            }

      - name: Generate release.yaml
        working-directory: cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw
        run: |
          cat > release.yaml << EOF 
          release:
            name: ${{ steps.release_name.outputs.value }}
            source:
              name: ${{ steps.getowner.outputs.repo_name }}
              version: ${{ inputs.release_version }}
              githubPackages:
                name: '${{ inputs.package_name }}'
                type: ${{ inputs.package_type }}
          EOF

      - name: Generate Global Inputs global-inputs.yaml
        working-directory: cd-${{ inputs.environment }}/${{ inputs.target_cloud }}
        run: |
          cat > global-inputs.yaml << EOF
          environment: ${{ inputs.deployment_name }}
          release_name: ${{ steps.release_name.outputs.value }}
          default:
            region: ${{ vars.DEPLOYMENT_AWS_REGION }}
            sts_role_arn: ${{ vars.DEPLOYMENT_STS_ROLE_ARN }}
          EOF

      - name: Generate state_conf.yaml from vars.DEPLOYMENT_STATE_CONF
        working-directory: cd-${{ inputs.environment }}/${{ inputs.target_cloud }}
        run: |
          cat > state_conf.yaml << EOF
          ${{ vars.DEPLOYMENT_STATE_CONF }}
          EOF

      - name: Terragrunt Plan
        id: plan
        working-directory: cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw
        run: terragrunt --terragrunt-non-interactive plan -no-color -input=false
        continue-on-error: false
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          GITHUB_API_TOKEN: ${{ secrets.token }}

      - name: Save Plan File
        uses: actions/upload-artifact@v4
        with:
          name: plan-file
          retention-days: 1
          path: |
            cd-${{ inputs.environment }}/**/apifiles/**/*
            cd-${{ inputs.environment }}/**/*.yaml
            cd-${{ inputs.environment }}/**/plan.tfplan
            !cd-${{ inputs.environment }}/**/.terragrunt-cache/**/*

  deployment-apply:
    needs:
      - deployment-plan
    runs-on: ubuntu-latest
    environment: ${{ inputs.deployment_name }}
    steps:
      - name: Checkout Base App Template
        uses: actions/checkout@v4
        with:
          repository: cloudopsworks/base-app-template
          path: cd-${{ inputs.environment }}
          fetch-depth: 1
          ref: v${{ env.base_app_version }}
          token: ${{ secrets.token }}

      - name: Restore Plan File
        uses: actions/download-artifact@v4
        with:
          name: plan-file
          path: cd-${{ inputs.environment }}

      - name: Setup OpenTofu
        id: setup_opentofu
        uses: opentofu/setup-opentofu@v1
        with:
          tofu_version: ${{ env.tofu_version }}
          tofu_wrapper: false

      - name: Setup Terragrunt v${{ env.tg_version }}
        run: |
          sudo wget -q -O /bin/terragrunt "https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.tg_version }}/terragrunt_linux_amd64"
          sudo chmod +x /bin/terragrunt
          terragrunt -v

      - name: Terragrunt Apply
        id: apply
        working-directory: cd-${{ inputs.environment }}/${{ inputs.target_cloud }}/apigw
        run: terragrunt --terragrunt-non-interactive apply -no-color plan.tfplan
        continue-on-error: false
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          GITHUB_API_TOKEN: ${{ secrets.token }}
